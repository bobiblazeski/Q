/**
 * Amend left list object with keys from right list objects
 * joining by key
 *
 * @func
 * @memberOf Q
 * @category List
 * @param {List} left - The original list
 * @param {List} right - The extension list
 * @param {String} lKey - The original list key
 * @param {String} rKey - The extension list key, if a omitted assumed equal with lKey
 * @return {Function} The predicate function.
 * @example
 *
 *         var left = [{ id:1, b:2},{ id:2, b:2}];
 *         var right =[{ id:1, d:4},{ id:2, d:5}];
 *         Q.amend(left,right,'id') => [{"id":1,"b":2,"d":4},{"id":2,"b":2,"d":5}]
 */
Q.amend = function (left, right, lKey, rKey) {
    rKey = rKey || lKey;
    return Q.map(function (l) {
        var found = find(function (r) {
            return l[lKey] == r[rKey];
        }, right);
        return Q.mixin(l, found ? found : {});
    }, left);
};

/**
 * Splits a list into sub-lists stored in an object, based on the result of calling a String-returning function
 * on each element, and grouping the results according to values returned.
 *
 * @func
 * @memberOf Q
 * @category List
 * @param {Function|String} f - function or string
 * @param {Array} list The array to group
 * @return {Object} An object with the output of `f` for keys, mapped to arrays of elements
 *         that produced that key when passed to `f`.
 * @example
 *
 * Q.group(function(num) { return Math.floor(num); },[4.2, 6.1, 6.4]) =>( { '4': [4.2], '6': [6.1, 6.4] })
 */
Q.group = _curry2(function (f, list) {
    var fn = typeof f == 'function' ? f : Q.field(f);
    return Q.fold(function (acc, elt) {
        var key = fn(elt);
        acc[key] = acc[key] ? acc[key].concat(elt) : [elt];
        return acc;
    }, {}, list);
});

function _keyValue(fn, list) {
    return Q.map(function(item) {return {key: fn(item), val: item};}, list);
}

function _compareKeys(a, b) {
    return a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
}
/**
 * Sorts the list according to a key generated by the supplied function.
 *
 * @func
 * @memberOf Q
 * @category relation
 * @sig (a -> String) -> [a] -> [a]
 * @param {Function|String} f The function mapping `list` items to keys, or property string.
 * @param {Array} list The list to sort.
 * @return {Array} A new list sorted by the keys generated by `f`.
 * @example
 *
 * var entries = [{ name: 'ALICE', age: 101 }, {name: 'Bob',age: -400},{name: 'clara',age: 314.159}];
 * Q.sort(function(d){ return Math.abs(d.age);},entries)
 * => [{"name":"ALICE","age":101},{"name":"clara","age":314.159},{"name":"Bob","age":-400}]
 *  Q.sort("age", [{ name: 'ALICE', age: 101 }, {name: 'Bob',age: -400},{name: 'clara',age: 314.159}])
 * => [{"name":"Bob","age":-400},{"name":"ALICE","age":101},{"name":"clara","age":314.159}]
 *  Q.sort("-age", [{ name: 'ALICE', age: 101 }, {name: 'Bob',age: -400},{name: 'clara',age: 314.159}])
 * =>[{"name":"clara","age":314.159},{"name":"ALICE","age":101},{"name":"Bob","age":-400}]
 */
Q.sort = _curry2(function (f, list) {
    var fn = typeof f == 'function' ? f
        : f[0] == '-' ? function (d) {
        return -1 * d[f.substring(1)]
    } : Q.field(f);
    return Q.pluck('val', _keyValue(fn, list).sort(_compareKeys));
});

function _joinComparator(on){
    if(typeof  on == 'string') {
        return function(left,right){
            return left[on] == right[on];
        }
    }
    var leftKey = on[0],
        rightKey = on[1];
    return function(left,right){
        return left[leftKey] == right[rightKey];
    }
}

function _joinSelector(columns){
    return function(left,right){
        return Q.pick(columns,mixin(left,right));
    }
}

/**
 * Returns an inner join of two arrays.
 *
 * @func
 * @memberOf Q
 * @category List
 * @param {String|Array|Function} on - it could be either string, array of two string or function
 * @param {Array|Function} columns - it could be either array of strings or function
 * @param {Array} left - left array of objects to be joined
 * @param {Array} right - right array of objects to be joined
 * @return {*} The inner join of the arrays
 * @example
 *
 *      Q.join("id", ["a","b"],[{id:1, a: 1},{id:2,a:3}],[{id:1, b: 11},{id:22,a:33}]) // =>([{ a: 1, b:11}]);
 *
 */
Q.join = _curry4(function(on,columns,left,right) {
    var leftLen = left.length,
        rightLen = right.length,
        res = [],
        comparator = typeof on == 'function' ? on  : _joinComparator(on),
        selector = typeof columns == 'function' ? columns : _joinSelector(columns);
    for(var l = 0; l < leftLen; ++l) {
        for(var r = 0; r < rightLen; ++r) {
            if(comparator(left[l],right[r])) {
                res.push(selector(left[l],right[r]));
            }
        }
    }
    return res;
});